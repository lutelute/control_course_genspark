<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第11回：オブザーバ</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        }
      };
    </script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            border-bottom: 1px solid #bdc3c7;
            padding-bottom: 5px;
            margin-top: 30px;
        }
        h3 {
            color: #2c3e50;
            margin-top: 25px;
        }
        h4 {
            color: #34495e;
            margin-top: 20px;
        }
        pre {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            background: #f1f2f6;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .nav-link {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #3498db;
            color: white;
            padding: 10px 15px;
            text-decoration: none;
            border-radius: 5px;
            z-index: 1000;
        }
        .nav-link:hover {
            background: #2980b9;
        }
        .motivation-box {
            background: #e8f6f3;
            padding: 20px;
            border-left: 4px solid #16a085;
            margin: 20px 0;
            border-radius: 5px;
        }
        .important-note {
            background: #fef5e7;
            padding: 15px;
            border-left: 4px solid #f39c12;
            margin: 20px 0;
            border-radius: 5px;
        }
        .step-box {
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 3px solid #3498db;
        }
        ul {
            padding-left: 20px;
        }
        li {
            margin: 8px 0;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="nav-link">← ダッシュボードに戻る</a>
    <div class="container">

<h1>第11回：オブザーバ</h1>

<h2>学習目標</h2>
<ul>
<li>オブザーバ（状態推定器）の原理を理解する</li>
<li>同一次元オブザーバと最小次元オブザーバを学ぶ</li>
<li>分離定理を理解し、観測器併合制御系を設計する</li>
</ul>

<h2>1. はじめに</h2>

<p>前回、状態フィードバック制御を学びましたが、実際のシステムではすべての状態変数を直接測定できるとは限りません。本講では、出力測定から状態を推定する<strong>オブザーバ（observer）</strong>または<strong>状態推定器（state estimator）</strong>の設計方法を学びます。</p>

<h2>2. オブザーバの必要性</h2>

<h3>2.1 実用上の問題</h3>

<ul>
<li>すべての状態変数にセンサを取り付けることは、コストや物理的制約から困難</li>
<li>一部の状態変数は測定不可能（内部温度、化学反応の中間生成物など）</li>
<li>センサノイズを低減するためのフィルタとしても機能</li>
</ul>

<h3>2.2 オブザーバの役割</h3>

<p>オブザーバは、以下の情報から状態を推定します：</p>
<ul>
<li>システムの数学モデル（$\mathbf{A}, \mathbf{B}, \mathbf{C}$）</li>
<li>制御入力 $\mathbf{u}(t)$</li>
<li>出力測定値 $\mathbf{y}(t)$</li>
</ul>

<h2>3. 同一次元オブザーバ（Full-Order Observer）</h2>

<h3>3.1 オブザーバの着想と基本構造</h3>

<h4>なぜオブザーバという考え方が生まれるのか？</h4>

<div class="motivation-box">
<p>実システムとまったく同じダイナミクスをもつ「模擬システム」を考えてみましょう：</p>

<p><strong>模擬システム（Open Loop Copy）：</strong></p>
<p>$$\dot{\tilde{\mathbf{x}}} = \mathbf{A}\tilde{\mathbf{x}} + \mathbf{B}\mathbf{u}$$</p>

<p>ここで、$\tilde{\mathbf{x}}$は模擬システムの状態です。理論的には、初期条件 $\tilde{\mathbf{x}}(0) = \mathbf{x}(0)$ と完全なモデル $(\mathbf{A}, \mathbf{B})$ があれば、$\tilde{\mathbf{x}}(t) = \mathbf{x}(t)$ となります。</p>
</div>

<div class="important-note">
<p><strong>しかし、この方法には致命的な問題があります：</strong></p>

<ol>
<li><strong>初期条件の不確実性</strong>：$\mathbf{x}(0)$ が正確にわからない</li>
<li><strong>モデル誤差</strong>：$\mathbf{A}, \mathbf{B}$ が不正確</li>
<li><strong>外乱の影響</strong>：予期しない外乱が作用</li>
<li><strong>積分誤差</strong>：時間とともに誤差が蓄積</li>
</ol>

<p>これらの理由により、開ループの模擬システムでは実用的な状態推定ができません。</p>
</div>

<h4>出力フィードバックによる補正の必要性</h4>

<p>そこで、<strong>実測可能な出力情報を使って模擬システムを補正</strong>するアイデアが生まれます：</p>

<div class="step-box">
<p><strong>補正のメカニズム：</strong></p>
<pre>
実システム：   ẋ = Ax + Bu  →  y = Cx
模擬システム：  ẋ̂ = Ax̂ + Bu  →  ŷ = Cx̂
                      ↓
               補正項：L(y - ŷ)
</pre>
</div>

<p>模擬システムの出力 $\hat{\mathbf{y}} = \mathbf{C}\hat{\mathbf{x}}$ と実システムの出力 $\mathbf{y} = \mathbf{C}\mathbf{x}$ に差がある場合、これは推定に誤差があることを意味します。</p>

<div class="important-note">
<p><strong>出力誤差 $\mathbf{y} - \hat{\mathbf{y}}$ の物理的意味：</strong></p>
<ul>
<li>$\mathbf{y} - \hat{\mathbf{y}} = \mathbf{C}(\mathbf{x} - \hat{\mathbf{x}}) = \mathbf{C}\mathbf{e}$</li>
<li>これは状態推定誤差 $\mathbf{e} = \mathbf{x} - \hat{\mathbf{x}}$ を出力空間で観測したもの</li>
<li>この情報を使って推定状態を補正できる！</li>
</ul>
</div>

<h4>なぜ行列 <strong>L</strong> が重要なのか？</h4>

<p>出力誤差 $(\mathbf{y} - \hat{\mathbf{y}})$ をそのまま状態に加えるわけにはいきません：</p>

<div class="step-box">
<p><strong>次元の問題：</strong></p>
<ul>
<li>状態 $\mathbf{x} \in \mathbb{R}^n$（例：n次元）</li>
<li>出力 $\mathbf{y} \in \mathbb{R}^p$（例：p次元、通常 $p < n$）</li>
</ul>

<p><strong>行列 $\mathbf{L} \in \mathbb{R}^{n \times p}$ の役割：</strong></p>
<p>$$\mathbf{L}(\mathbf{y} - \hat{\mathbf{y}}) \in \mathbb{R}^n$$</p>

<p>行列 $\mathbf{L}$ は「出力誤差を状態空間の各成分にどのように分配するか」を決定します。</p>
</div>

<div class="motivation-box">
<p><strong>直感的な理解：</strong></p>
<ul>
<li>$\mathbf{L}$ の各列は、対応する出力誤差成分が各状態推定値にどう影響するかを表す</li>
<li>例えば、$\mathbf{L}$ の第1列は、第1出力の誤差 $(y_1 - \hat{y}_1)$ が各状態推定値 $\hat{x}_1, \hat{x}_2, \ldots, \hat{x}_n$ に与える補正を表す</li>
</ul>
</div>

<h4>オブザーバの最終形</h4>

<p>以上の考察から、<strong>オブザーバ（状態推定器）</strong>の構造が導かれます：</p>

<div class="step-box">
<p><strong>システム：</strong></p>
<p>$$\dot{\mathbf{x}} = \mathbf{A}\mathbf{x} + \mathbf{B}\mathbf{u}$$
$$\mathbf{y} = \mathbf{C}\mathbf{x}$$</p>

<p><strong>オブザーバ：</strong></p>
<p>$$\dot{\hat{\mathbf{x}}} = \mathbf{A}\hat{\mathbf{x}} + \mathbf{B}\mathbf{u} + \mathbf{L}(\mathbf{y} - \hat{\mathbf{y}})$$
$$\hat{\mathbf{y}} = \mathbf{C}\hat{\mathbf{x}}$$</p>
</div>

<div class="important-note">
<p><strong>各項の物理的意味：</strong></p>
<ul>
<li>$\mathbf{A}\hat{\mathbf{x}}$：推定状態の自然な発展（システムの内在ダイナミクス）</li>
<li>$\mathbf{B}\mathbf{u}$：制御入力の既知の効果</li>
<li>$\mathbf{L}(\mathbf{y} - \hat{\mathbf{y}})$：出力測定に基づく推定補正
  <ul>
    <li>$\mathbf{y} - \hat{\mathbf{y}}$：<strong>イノベーション</strong>（新しい情報）</li>
    <li>$\mathbf{L}$：<strong>オブザーバゲイン</strong>（補正の強さと方向を制御）</li>
  </ul>
</li>
</ul>

<p>この構造により、オブザーバは「予測」（モデルベース）と「補正」（測定ベース）を組み合わせた推定器となります。</p>
</div>

<p>残りの内容（推定誤差のダイナミクス、極配置、具体例など）は元のファイルと同じです...</p>

    </div>
</body>
</html>